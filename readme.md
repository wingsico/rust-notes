# Rust Learning Notes

## 20201203

### Knowledge Points

1. Rust 智能提示偶尔失效，需要安装 Rust-Analyser 插件, 参考 issue: <https://github.com/rust-lang/vscode-rust/issues/835>

2. Rust 使用 `&` 来**创建**一个指向变量值的引用(_ref_)，并不拥有所有权。

3. Rust 使用 `*` 来完成与 `&` 相反的操作，称之为**解引用**。

4. 当我们在 Rust 的函数参数中使用 `&` 来标识引用时，被称之为**借用**

5. **借用**是默认不可修改的，和变量默认不可修改一样

6. 可以使用**可变引用**来使借用拥有修改能力，即 `mut`(变量定义), `&mut`(实参和形参使用)

7. Rust 不允许在同一特定作用域里产生多个**可变引用**，这是一个受限制的方式，不过可以有效地避免**数据竞争**。
8. 类似 JS，我们就可以在多个地方对同一个对象进行访问并修改，此类问题只能通过编程人员靠编程能力解决。
9. Rust 则在编译阶段直接避免了此类情况出现的可能，若有这种情况，则编译不通过。
10. Rust 的**可变引用**和所有权一样，都不能同时被多个变量拥有。如果希望创建多个可变引用，则可以使用 `{}` 创建新的作用域，让不同的可变引用存在于不同的作用域中。(_此处强调可变引用_)

11. 多个不可变引用是可以共存的，因为不可变引用只发生读而不会写入，不会造成数据竞争问题。但是不能在**同一个引用作用域**内同时存在一个变量的不可变引用和可变引用，Rust 不允许这样的情况发生(_在编译期阻止_)，这种情况仍然会出现**数据竞争**。

12. 引用作用域：引用的作用域范围是，从创建引用开始的地方直到引用最后一次使用的地方为止。

13. 如果引用作用域不重合，是可以存在多个可变引用和不可变引用或混合引用(_不可变和可变引用都存在_)。

14. 悬垂指针：指针存在但指针指向的内存区域已经被释放或被分配给其他持有者。

    ```rust
    fn dangle() -> &String { // dangle 返回一个字符串的引用

        let s = String::from("hello"); // s 是一个新字符串

        &s // 返回字符串 s 的引用
    } // 这里 s 离开作用域并被丢弃。其内存被释放。
    ```

15. 获取迭代器： `s.as_bytes().iter()`

16. 使用元组包装迭代器结果： `s.as_bytes().iter().enumerate()`

17. `slice` 也是一种引用，类型是 `&str`，直接硬编码创建的字符串字面量也是 `slice`，可以使用 `&s[1..5]` 方式取 `String 或 &String` 的 `slice`

18. 每个使用引用的变量本身也是拥有其自身的所有权的，因为引用也是一个值，_在 Rust 中每一个值都有一个被称为其**所有者**的变量_。**但不一样的是**，由于其值是个引用，并不拥有这个值本身，因此当使用引用的变量离开作用域后，其引用指向的值也不会被丢弃。

    ```rust
    let a = String::from("demo");

    let b = &a;
    let c = b;

    println!("{}", b); // error , borrowed by c
    ```

19. 基本类型（_存储在栈上_）是直接 `Copy` 的，也就不存在 `Move`, `Borrow` 的情况。例如整数、布尔值、浮点数、字符，以及只包含前面所有类型的元组

20. 若要返回多个值可以使用元组的方式，并通过元组的模式匹配来取值

21. 一个值是可变的，它的引用也可以是不可变的，当使用了不可变引用时，就不可以再获取一个可变引用了（_根据可变与不可变引用的规则_）

### Confusion

1. 将变量传递给函数会交出所有权，为什么在调用 `println!()` 后，仍能够使用该变量？

```rust
let e = &mut a;

println!("{}", e);

println!("{}", e); // 为什么仍然可以使用？
```

通过搜索答案得知：Rust 会对宏定义进行编译，而在编译展开后的代码，实际上是使用了不可变引用 `&`。(_参考<https://xie.infoq.cn/article/84237177d2091bd399817468f>_)

## 20201204

### Knowledge Points

1. 结构体可以整体可变，但不允许只有单个字段 `field` 可变

2. 与 ES6 一样，在 Rust 的结构体中，当变量名和字段名同名时，可以直接使用名称简写

   ```js
   let username = "549";
   let obj = {
     username,
   };
   ```

   ```rust
   let username = '549';
   let user = User {
     username,
   }
   ```

3. 在 Rust 中也有类似 ES6 的拓展运算符，但作用优先级不一样

   ```rust
   let user1 = User {
     name: "549",
     age: 18
   }

   let user2 = User {
     name: "wingsico",
     ..user1, // 重用 user1 中的 age，但不覆盖 name
   }

   user2.name // "wingsico"
   user2.age // 18
   ```

4. 元组结构体：命名的元组，不同命名的元组隶属于不同的类型。（但总觉得这样带来了额外的理解成本，但也有好处，就是可以使用模式匹配/索引来取值）

   ```rust
   struct Point(i32, i32, i32);
   struct Color(i32, i32, i32);
   ```

5. 结构体中可以使用被其他对象所拥有的数据的引用，但往往我们希望结构体的有效性与其数据的有效性保持一致（_当使用引用时，可能存在不一致的情况_），Rust 针对这种情况，使用了 **生命周期**，生命周期可以确保结构体引用的数据有效性跟结构体本身保持一致。若在结构体中使用引用而不指定声明周期，Rust 会拒绝通过编译来保证一致性。

6. 使用 `println!()` 宏去打印结构体时，需要实现 `Display` trait，若没有实现，在编译时会报错。根据其报错信息，我们可以使用 `{:?}` 或 `{:#?}` 来尝试调用 `Debug` trait，发现仍然是没有实现。但是 `Debug` trait 在 Rust 是默认提供了，我们只需要在我们的结构体上加上 `#derive[Debug]` 来标识实现的 `Debug` trait 即可

### Confusion

1. 类单元结构体具体描述在 第五章并没有讲到，但翻阅一些源码中看到类似的写法：

   ```rust
   struct Demo(());
   ```

   有点类似元组结构体，但没有任何参数，不确定是不是类单元结构体。

   update：以上的写法仍然为元组结构体，类单元结构体的结构如下：

   ```rust
   struct Demo;
   ```

## 20201205

### Knowledge Points

1.  `*`, `&` 优先级低于 `.`, `()`

2.  相比于 C++，Rust 没有类似 `->` 的运算符来直接去调用对象上的方法，例如 `object->something()`，此处 object 是一个指针，something 是该指针指向的对象的方法。在 Rust 中，我们可以直接使用 `object.something()`，因为 Rust 在调用方法时会自动帮我们进行 **加引用或解引用**。这里就要解释一下为什么 Rust 可以完成这种 **自动引用**，这是因为在定义结构体方法时，是通过如下方式定义的：

    ```rust
    struct User {
      name: String,
    }

    impl User {
      pub fn print_name(&self) {
        println!("{}", self.name);
      }
    }
    ```

    这种方式在定义第一个参数（_第一个参数一定是指向结构体的实例的_）时已经指定了使用实例的方式（`&self` 不可变引用， `&mut self` 可变引用，`self` 获取所有权），那么在调用时就无需手动去加引用或解引用来匹配类型（当然我们也可以手动进行类型匹配，但完全没有必要，Rust 已经帮我自动做了）

3.  结构体实例的某个属性若被获取了所有权，被称为该结构体被部分地获取了所有权。因此该结构体的所有权相当于被分割了，若想使用整个结构体则编译不通过，只能部分地使用未被获取所有权的属性。

4.  如果我们故意不想使用某个结构体方法的话，可以使用 `_` 作为方法前缀，这样可以让 Rust 编译器了解你的意图，同意编译通过。同样，对于一些测试或兜底函数，参数仅仅用来测试，在函数内也不会使用，那么也可以使用 `_` 开头作为参数名，让代码可以成功编译，例如下面的函数：

    ```rust
    fn noop(_u: User) {}
    ```

## 20201206

### Knowledge Points

1. 代数数据类型

2. Rust 中枚举的定义方式与其他语言类似，但使用时的语法为 `Color::red`，使用 `::` 来指定枚举值，同时，可以通过类似调用结构体实例无关方法一样，传入一些参数：

   ```rust
   enum Color {
     Red(f32),
     Green(f32, i32)
   }

   let light_red = Color::Red(0.4);
   ```

3. 通过枚举值的参数，我们可以将任意类型的数据放入枚举成员中：例如字符串、数字类型或者结构体（_使用结构体可以让我们的枚举成员带有更多的附加信息_）

4. Rust 中的枚举相当灵活，枚举成员可以是各种各样的结构体类型：

   ```rust
   #[derive(Debug)]
   enum Operation {
     Del, // 枚举类单元结构体
     Add(f32), // 枚举元组结构体
     Add2d(f32, f32), // 枚举元组结构体
     Move { // 枚举匿名结构体
       x: f32,
       y: f32,
     },
     Sub(f32),
   }

   impl Operation {
     pub fn get_first(&self) {
       println!("{:#?}", self)
     }
   }
   ```

   但不同类型的枚举成员不可重名。

5. Rust 的枚举成员都所属于一个类型，利用这点我们可以实现在面向对象编程中非常常见的 **LSP**（里氏代换原则），但使用枚举来做这样的事情感觉不太优雅，并且可能还会有一些坑点，在第十七章的时候 Rust 圣经中会讲述 Rust 的面向对象编程特性，到时候再一探究竟。

6. 虽然枚举中可以使用各种结构体，但枚举也最好仅仅当做枚举使用，而非其他。

7. `Option<T>` 是一个非常重要的标准库中的枚举类型，用来替代传统编程语言中的 Null，防止在运行期出现类似 Java 中的典型错误*空指针异常*。

8. Rust 通过 `Option<T>` 的方式在编译期就避免了运行时可能出现的空指针问题，因为 Option 类型无法直接像正常的值那样使用，必须通过 match 来保证正常值和空值都得到了有效的处理。看以下的例子：

   ```Rust
   let x: Option<Operation> = Some(Operation::Sub(30.0));

   // x.get_first(); // 不允许的使用方式

   // match 处理非空值和空值
   match x {
     Some(v) => v.get_first(),
     None => println!("Empty Operation")
   }
   ```

9. 有了 `Option` 的存在，我们在使用值的时候就不必提心吊胆，只要是非 `Option` 的类型，我们都可以认为它是必定非空的，就可以直接放心地使用。当我们遇到 `Option` 时，就能想起来需要去编写对应的空值处理 **（不愧是 Rust）**

10. Rust 的 `match` 是一个非常强大的基于**模式匹配**的控制流运算符。它的写法形式与其他语言中的 `switch` 类似，但功能却强大的多。除了正常的值匹配后进行的不同处理，在我看来, `match` 还有以下的功能：
    1. 直接返回值： `Something => 1`
    2. 类型匹配： `Coin::Penny => 1`
    3. 类型与值同时匹配并处理值： `Coin::Penny(v) => v + 1`, `Coin::Penny(3) => v + 2 // 若 value != 3 则不匹配` **(nice feature!)**
    4. 穷尽的匹配，在使用枚举时，可以在编译期知道你哪些值没有进行处理并给出警告。
    5. 单行多值匹配： `Coin::Penny | Coin::Dime => 1`
    6. if true 匹配：`d if d > 3 => 1`


11. 通过 `_` 可以在 `match` 中匹配所有选项，因此我们将 `_` 放在最后可以去匹配除了 `_` 之上列举的所有值，并且这样写避免了 `match` 的穷尽匹配机制，从而通过编译。

12. 当我们只要处理某个特殊场景时，由于穷尽匹配的机制，我们往往需要加上 `_ => ()` 类似这样的样板代码。出于这样的考虑，Rust 提供了 `if let`, `else` 语法（在我看来，这个语法有点难以阅读`
    
    ```rust
    let some_u8_value = Some(0u8);
    match some_u8_value {
      Some(v) => println!("{}", v),
      _ => (),
    }

    if let Some(v) = some_u8_value {
      println!("{}", v);
    } else {
      // do nothing
    }
    ```

### Confusion

1. Rust 中的枚举为什么要设置这么多种类型，实际的使用场景是什么？感觉如此之多的类型让我有些晕头转向
