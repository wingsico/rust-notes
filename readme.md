# Rust Learning Notes


## 20201203

### Knowledge Points

1. Rust 智能提示偶尔失效，需要安装 Rust-Analyser 插件, 参考 issue: https://github.com/rust-lang/vscode-rust/issues/835

2. Rust 使用 `&` 来**创建**一个指向变量值的引用(*ref*)，并不拥有所有权。

3. Rust 使用 `*` 来完成与 `&` 相反的操作，称之为**解引用**。

4. 当我们在 Rust 的函数参数中使用 `&` 来标识引用时，被称之为**借用**

5. **借用**是默认不可修改的，和变量默认不可修改一样

6. 可以使用**可变引用**来使借用拥有修改能力，即 `mut`(变量定义), `&mut`(实参和形参使用)

7. Rust 不允许在同一特定作用域里产生多个**可变引用**，这是一个受限制的方式，不过可以有效地避免**数据竞争**。
  1. 类似 JS，我们就可以在多个地方对同一个对象进行访问并修改，此类问题只能通过编程人员靠编程能力解决。
  2. Rust 则在编译阶段直接避免了此类情况出现的可能，若有这种情况，则编译不通过。
  3. Rust 的**可变引用**和所有权一样，都不能同时被多个变量拥有。如果希望创建多个可变引用，则可以使用 `{}` 创建新的作用域，让不同的可变引用存在于不同的作用域中。(*此处强调可变引用*)

8. 多个不可变引用是可以共存的，因为不可变引用只发生读而不会写入，不会造成数据竞争问题。但是不能在**同一个引用作用域**内同时存在一个变量的不可变引用和可变引用，Rust 不允许这样的情况发生(*在编译期阻止*)，这种情况仍然会出现**数据竞争**。

9. 引用作用域：引用的作用域范围是，从创建引用开始的地方直到引用最后一次使用的地方为止。

10. 如果引用作用域不重合，是可以存在多个可变引用和不可变引用或混合引用(*不可变和可变引用都存在*)。

11. 悬垂指针：指针存在但指针指向的内存区域已经被释放或被分配给其他持有者。

```rust
fn dangle() -> &String { // dangle 返回一个字符串的引用

    let s = String::from("hello"); // s 是一个新字符串

    &s // 返回字符串 s 的引用
} // 这里 s 离开作用域并被丢弃。其内存被释放。
```

12. 获取迭代器： `s.as_bytes().iter()`

13. 使用元组包装迭代器结果： `s.as_bytes().iter().enumerate()`

14. `slice` 也是一种引用，类型是 `&str`，直接硬编码创建的字符串字面量也是 `slice`，可以使用 `&s[1..5]` 方式取 `String 或 &String` 的 `slice`

15. 每个使用引用的变量本身也是拥有其自身的所有权的，因为引用也是一个值，*在Rust 中每一个值都有一个被称为其**所有者**的变量*。**但不一样的是**，由于其值是个引用，并不拥有这个值本身，因此当使用引用的变量离开作用域后，其引用指向的值也不会被丢弃。

```rust
let a = String::from("demo");

let b = &a;
let c = b;

println!("{}", b); // error , borrowed by c
```

16. 基本类型（*存储在栈上*）是直接 `Copy` 的，也就不存在 `Move`, `Borrow` 的情况。例如整数、布尔值、浮点数、字符，以及只包含前面所有类型的元组

17. 若要返回多个值可以使用元组的方式，并通过元组的模式匹配来取值

18. 一个值是可变的，它的引用也可以是不可变的，当使用了不可变引用时，就不可以再获取一个可变引用了（*根据可变与不可变引用的规则*）


### Confusion


1. 将变量传递给函数会交出所有权，为什么在调用 `println!()` 后，仍能够使用该变量？

```rust
let e = &mut a;

println!("{}", e);

println!("{}", e); // 为什么仍然可以使用？
```

通过搜索答案得知：Rust 会对宏定义进行编译，而在编译展开后的代码，实际上是使用了不可变引用 `&`。(*参考https://xie.infoq.cn/article/84237177d2091bd399817468f*)




## 20201204

### Knowledge Points

1. 结构体可以整体可变，但不允许只有单个字段 `field` 可变

2. 与 ES6 一样，在 Rust 的结构体中，当变量名和字段名同名时，可以直接使用名称简写

```js
let username = '549';
let obj = { 
  username 
};
```

```rust
let username = '549';
let user = User {
  username,
}
```

3. 在 Rust 中也有类似 ES6 的拓展运算符，但作用优先级不一样

```rust
let user1 = User {
  name: "549",
  age: 18
}

let user2 = User {
  name: "wingsico",
  ..user1, // 重用 user1 中的 age，但不覆盖 name
}

user2.name // "wingsico"
user2.age // 18
```


4. 元组结构体：命名的元组，不同命名的元组隶属于不同的类型。（但总觉得这样带来了额外的理解成本，但也有好处，就是可以使用模式匹配/索引来取值）

```rust
struct Point(i32, i32, i32);
struct Color(i32, i32, i32);
```

5. 结构体中可以使用被其他对象所拥有的数据的引用，但往往我们希望结构体的有效性与其数据的有效性保持一致（*当使用引用时，可能存在不一致的情况*），Rust 针对这种情况，使用了 **生命周期**，生命周期可以确保结构体引用的数据有效性跟结构体本身保持一致。若在结构体中使用引用而不指定声明周期，Rust 会拒绝通过编译来保证一致性。

6. 使用 `println!()` 宏去打印结构体时，需要实现 `Display` trait，若没有实现，在编译时会报错。根据其报错信息，我们可以使用 `{:?}` 或 `{:#?}` 来尝试调用 `Debug` trait，发现仍然是没有实现。但是 `Debug` trait 在 Rust 是默认提供了，我们只需要在我们的结构体上加上 `#derive[Debug]` 来标识实现的 `Debug` trait 即可

### Confusion

1. 类单元结构体具体描述在 第五章并没有讲到，但翻阅一些源码中看到类似的写法：

```rust
struct Demo(());
```

有点类似元组结构体，但没有任何参数，不确定是不是类单元结构体，*待更新*