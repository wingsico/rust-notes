## 20201210

### Knowledge Points

1. vector 是可变长的集合，存储在堆上，拥有泛型，使用 `Vec::new()` 可以调用 `Vec` 结构体上的静态方法 `new` 来创建一个 `Vec`；

2. vector 拥有方法 `vec!` ，可以直接初始化一个集合，`vec![1,2,3]`

3. vector 可以有好几种取数的方式，通过 `vec[@index]` 或 `&vec[@index]` 或 `vec.get(@index)`，其中直接通过 `[]` 去取值或引用容易在 runtime 发生 panic，而通过 `get` 返回的是 `Option`，可以通过 `macth` 语法或 `if let` 语法进行处理

4. `&vec[@index]` 和 `vec[@index]` 的区别在于，前者取的是集合元素的引用，也就产生了借用，后者是直接获取的元素的所有权，当 `vec` 中元素是基本类型时（也就是实现了 copy traits，或是存储在栈上），两者的效果是一致的，因为会直接复制一份。而对于存储在堆上使用引用访问的类型，后者是错误的，因为 `vec` 保持着其子元素的所有权，是无法从其中 move 出来的，只能使用 `&` 产生借用行为。

5. 同理，既然使用借用，就需要满足之前说的借用规则。复习一下：

    1. 同一时间段内，只能有一个可变引用或多个不可变引用
    2. 引用必须是有效的（引用所指向的内存空间不能被释放或被其他变量使用）

6. 类似 `vec.push` 的操作实际上是会产生借用行为，会使用 `vec` 的可变引用。

7. 丢弃 `vec` 时，其所有子元素也会被丢弃（除非子元素均为引用）

8. 当我们在使用 `vec.push` 时，会像集合结尾推入一个元素，但由于 `vec` 可能在推入新元素时所分配的内存空间不足，因此需要重新分配内存空间并将所有元素移动到新的空间中。那么每一个元素的内存地址实际上产生了变化。由于存在这种可能，Rust 禁止在使用 `push` 等类似方法的同时使用引用。


