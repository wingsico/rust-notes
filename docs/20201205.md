## 20201205

结构体的参数定义与使用

### Knowledge Points

1.  `*`, `&` 优先级低于 `.`, `()`

2.  相比于 C++，Rust 没有类似 `->` 的运算符来直接去调用对象上的方法，例如 `object->something()`，此处 object 是一个指针，something 是该指针指向的对象的方法。在 Rust 中，我们可以直接使用 `object.something()`，因为 Rust 在调用方法时会自动帮我们进行 **加引用或解引用**。这里就要解释一下为什么 Rust 可以完成这种 **自动引用**，这是因为在定义结构体方法时，是通过如下方式定义的：

    ```rust
    struct User {
      name: String,
    }

    impl User {
      pub fn print_name(&self) {
        println!("{}", self.name);
      }
    }
    ```

    这种方式在定义第一个参数（_第一个参数一定是指向结构体的实例的_）时已经指定了使用实例的方式（`&self` 不可变引用， `&mut self` 可变引用，`self` 获取所有权），那么在调用时就无需手动去加引用或解引用来匹配类型（当然我们也可以手动进行类型匹配，但完全没有必要，Rust 已经帮我自动做了）

3.  结构体实例的某个属性若被获取了所有权，被称为该结构体被部分地获取了所有权。因此该结构体的所有权相当于被分割了，若想使用整个结构体则编译不通过，只能部分地使用未被获取所有权的属性。

4.  如果我们故意不想使用某个结构体方法的话，可以使用 `_` 作为方法前缀，这样可以让 Rust 编译器了解你的意图，同意编译通过。同样，对于一些测试或兜底函数，参数仅仅用来测试，在函数内也不会使用，那么也可以使用 `_` 开头作为参数名，让代码可以成功编译，例如下面的函数：

    ```rust
    fn noop(_u: User) {}
    ```
