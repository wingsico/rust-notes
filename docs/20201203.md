## 20201203

所有权与引用

### Knowledge Points

1. Rust 智能提示偶尔失效，需要安装 Rust-Analyser 插件, 参考 issue: <https://github.com/rust-lang/vscode-rust/issues/835>

2. Rust 使用 `&` 来**创建**一个指向变量值的引用(_ref_)，并不拥有所有权。

3. Rust 使用 `*` 来完成与 `&` 相反的操作，称之为**解引用**。

4. 当我们在 Rust 的函数参数中使用 `&` 来标识引用时，被称之为**借用**

5. **借用**是默认不可修改的，和变量默认不可修改一样

6. 可以使用**可变引用**来使借用拥有修改能力，即 `mut`(变量定义), `&mut`(实参和形参使用)

7. Rust 不允许在同一特定作用域里产生多个**可变引用**，这是一个受限制的方式，不过可以有效地避免**数据竞争**。

8. 类似 JS，我们就可以在多个地方对同一个对象进行访问并修改，此类问题只能通过编程人员靠编程能力解决。

9.  Rust 则在编译阶段直接避免了此类情况出现的可能，若有这种情况，则编译不通过。
    
10. Rust 的**可变引用**和所有权一样，都不能同时被多个变量拥有。如果希望创建多个可变引用，则可以使用 `{}` 创建新的作用域，让不同的可变引用存在于不同的作用域中。(_此处强调可变引用_)

11. 多个不可变引用是可以共存的，因为不可变引用只发生读而不会写入，不会造成数据竞争问题。但是不能在**同一个引用作用域**内同时存在一个变量的不可变引用和可变引用，Rust 不允许这样的情况发生(_在编译期阻止_)，这种情况仍然会出现**数据竞争**。

12. 引用作用域：引用的作用域范围是，从创建引用开始的地方直到引用最后一次使用的地方为止。

13. 如果引用作用域不重合，是可以存在多个可变引用和不可变引用或混合引用(_不可变和可变引用都存在_)。

14. 悬垂指针：指针存在但指针指向的内存区域已经被释放或被分配给其他持有者。

    ```rust
    fn dangle() -> &String { // dangle 返回一个字符串的引用

        let s = String::from("hello"); // s 是一个新字符串

        &s // 返回字符串 s 的引用
    } // 这里 s 离开作用域并被丢弃。其内存被释放。
    ```

15. 获取迭代器： `s.as_bytes().iter()`

16. 使用元组包装迭代器结果： `s.as_bytes().iter().enumerate()`

17. `slice` 也是一种引用，类型是 `&str`，直接硬编码创建的字符串字面量也是 `slice`，可以使用 `&s[1..5]` 方式取 `String 或 &String` 的 `slice`

18. 每个使用引用的变量本身也是拥有其自身的所有权的，因为引用也是一个值，_在 Rust 中每一个值都有一个被称为其**所有者**的变量_。**但不一样的是**，由于其值是个引用，并不拥有这个值本身，因此当使用引用的变量离开作用域后，其引用指向的值也不会被丢弃。

    ```rust
    let a = String::from("demo");

    let b = &a;
    let c = b;

    println!("{}", b); // error , borrowed by c
    ```

19. 基本类型（_存储在栈上_）是直接 `Copy` 的，也就不存在 `Move`, `Borrow` 的情况。例如整数、布尔值、浮点数、字符，以及只包含前面所有类型的元组

20. 若要返回多个值可以使用元组的方式，并通过元组的模式匹配来取值

21. 一个值是可变的，它的引用也可以是不可变的，当使用了不可变引用时，就不可以再获取一个可变引用了（_根据可变与不可变引用的规则_）

### Confusion

1. 将变量传递给函数会交出所有权，为什么在调用 `println!()` 后，仍能够使用该变量？

```rust
let e = &mut a;

println!("{}", e);

println!("{}", e); // 为什么仍然可以使用？
```

通过搜索答案得知：Rust 会对宏定义进行编译，而在编译展开后的代码，实际上是使用了不可变引用 `&`。(_参考<https://xie.infoq.cn/article/84237177d2091bd399817468f>_)
