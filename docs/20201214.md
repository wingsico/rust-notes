## 20201214

### Knowledge Points

1.  Rust 特性：Rust 倾向于确保暴露出可能的错误。
2.  Rust 中，字符串是以 utf-8 进行编码的。
3.  Rust 中，只有一种字符串类型 str，而在我们的代码中，是不允许直接访问 str 的，我们通常直接使用它的借用形式 `&str` 以及 `slice` 切片。
4.  `&str` 引用指向的区域是硬编码在程序的二进制输出中的。
5.  `String` 是非核心语言特性，由标准库提供，具有以下特性：
    1. 可增长的
    2. 可变的
    3. 有所有权的
    4. UTF-8 编码
6.  除了 `&str` _(我们往往这样使用)_ 和 `String`，标准库中还额外提供了一系列其他的字符串类型，例如 `OsString`、`OsStr` 等。他们以 `String` 和 `Str` 结尾，对应这它们会提供 **所有权(String)** 和 **可借用(Str)** 的字符串变体。它们可能会以不同的编码或在内存上不同的表现形式来存储文本。
7.  `+` 运算符实际上调用的是 `add` 函数，签名如下：

    ```rust
    fn add(self, s:&str) -> String {
    ```

    因此 `+` 的左侧标识符会产生 Move 行为，右侧产生借用。

    同理，在多个字符串相加时，需要采用如下的方式：
    ```rust
    let str1 = String::from("Hello ");
    let str2 = String::from("World");
    let str3 = String::from("!")

    let str4 = str1 + &str2 + &str3;
    // 此时 str1 的所有权转移到 str4
    // str2, str3 产生借用行为
    ```

10. 使用 `+` 运算符往往会产生一些困惑，我们可以使用 `format!` 宏来完成字符串拼接操作：

    ```rust
    let str4 = format!("{}{}{}", str1, str2, str3);
    // 不产生Move, 只有借用
    println!("{}{}{}", str1, str2, str3); // 有效！
    ```

11. Rust 字符串内部实际上是按 `vec<u8>` 来存储的，每一个字符需要一个字节或多个字节存储。可通过 `str.len()` 来获取字符串占用的字节数。

12. Rust 的字符串**不支持按索引进行字符选择**： 
    1. 由于对于一些 Unicode 标量值，需要多个字节存储，单个字节是无效的字符。举个栗子：`🏷` 的长度是 4，表示该字符占用了 4 个字节，它存储在 vector 中的 `u8` 值是如下形式：

        ```rust
        [240,159,143,183]
        ```
        
        当我们使用索引 `&str[0]` 访问时，实际上应该返回 `240`，但 `240` 本身不是一个有效的字母，而使用索引访问第一个字母的人也不会期望看到 `240` 这个数字。由于 Rust 默认安全，会避免一些可能发生的意外，因此在编译期就杜绝了此类问题的发现（因为他们并不能通过编译）。

13. Rust 中有三种方式来理解字符串：
    1.  字节 -> 字符串占用的字节数，实际上是一个个 `u8` 值。
    2.  标量值 -> 从 Unicode 标量值的角度看，类似是一个个可显示的字符（和 `char` 类似）
    3.  字型簇 -> 就是最终呈现在我们面前的字符

14. Rust 还有一个不允许使用索引来获取 String 字符的原因是，索引操作总是预期 `O(1)` 的时间复杂度，但在 Rust 中，`String` 无法保证这样的性能，它必须从开头到索引位置进行遍历来确定多少有效的字符。

15. 同样的，我们有 slice 语法，是使用 `&str[0..3]` 类似的语法进行取字符串片段，同样需要遵循以上规则，其中数字是按字符串的字节数进行截取的。


16. 字符串提供了一些方法来获取字节集合、字符集合，(`.bytes()`、`.chars()`)，但从字符串中获取字型簇是非常复杂的，标准库未提供类似功能。



